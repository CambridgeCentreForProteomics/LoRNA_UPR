---
title: "NNLS for differential localisation"
author:
  - name: "Tom Smith"
    affiliation: "Cambridge Centre for Proteomics"
date: "`r format(Sys.time(), '%d %B, %Y')`"
abstract: | 
  Here, we use NNLS for proportional localisation assignment
output:
  pdf_document:
  html_notebook: default
geometry: margin=1in
fontsize: 11pt
---
```{r}
library(pRoloc)
library(pRolocExt)
library(tidyverse)
library(camprotR)
library(glmnet)
library(pbapply)
```
Read in the data and subset to gene-level SIRV-corrected datasets
```{r}

all_datasets <- readRDS('../2_clustering/out/all_datasets_with_novel.rds')

all_datasets$gene$DMSO <- all_datasets$gene$DMSO$corrected
all_datasets$gene$Tg <- all_datasets$gene$Tg$corrected

all_datasets$transcript$DMSO <- all_datasets$transcript$DMSO$corrected
all_datasets$transcript$Tg <- all_datasets$transcript$Tg$corrected

```


Define a function to estimate proportions using the average profiles for markers


```{r}
# obj = 
get_proportions <- function(obj,
                            iterations,
                            sample=TRUE,
                            sample_proportion=1,
                            n=NULL,
                            cores=4,
                            remove_markers='Membrane',
                            remove_mt_rnas=TRUE){
  obj <- obj %>% filterNA()
      
  ########
  # get average profiles for all localisations excepting Membrane,
  # with boostrapping proceedure to sample the markers
  complete_data <- obj[! fData(obj)$markers %in% remove_markers,]
      
  complete_data <- complete_data[fData(complete_data)$markers!='unknown',]
  complete_rows <- rownames(complete_data)
  
  sampled_data <- 1:iterations %>% pblapply(function(x){
      if(sample){
        sampled_row <- sample(complete_rows, length(complete_rows)*sample_proportion, replace=TRUE) 
        sampled_e <- exprs(complete_data)[sampled_row,]
        sampled_f  <- fData(complete_data)[sampled_row,]
        rownames(sampled_e) <- 1:nrow(sampled_e)
        rownames(sampled_f) <- 1:nrow(sampled_f)
        
        MSnSet(sampled_e, sampled_f)
        
      } else{complete_data}
    }, cl=cores)

  names(sampled_data) <- 1:iterations
  
  sampled_data <- sampled_data[sapply(sampled_data, FUN=function(x){
    length(getMarkerClasses(x))==length(getMarkerClasses(complete_data))})]
  
  ave_profiles <- sampled_data %>% pblapply(function(x){
    mrkConsProfiles(x)
  }, cl=cores)
  ########
  
  if(remove_mt_rnas){
    # Remove RNAs encoded in the mitochondrial genome. These are all Mt markers
    obj <- obj[fData(obj)$chromosome_name != 'MT', ]
  }
  
  if(missing(n)){
    n <- nrow(obj)
  }

  
  rows <- pblapply(1:n, function(row_id){
  
  
    iteration_results <- lapply(ave_profiles, function(ave_profile){
      
      indep_var <- t(ave_profile)
      
      fit <- glmnet(indep_var,
                    exprs(obj)[row_id,],
                    family='gaussian',
                    lower.limits=0,
                    lambda=0,
                    alpha=0)
      
      coefs <- coefficients(fit)[,1]
      
      coefs[2:length(coefs)] <- coefs[2:length(coefs)]/sum(coefs[2:length(coefs)])
      
      return(c(coefs, 'var_explained'=fit$dev.ratio))
      }) %>% do.call(what='rbind')

    iteration_results_summarised <- lapply(2:nrow(iteration_results), function(n){
        mean_values <- apply(iteration_results[1:n,], MARGIN=2, mean)
        sd <- apply(iteration_results[1:n,], MARGIN=2, sd)
        names(mean_values) <- paste0('mean_', names(mean_values))
        names(sd) <- paste0('sd_', names(sd))
        
        return(c(sd, mean_values, 'iterations'=n))
      }) %>% do.call(what='rbind') %>%
      apply(MARGIN=2, FUN=mean)
    
    return(iteration_results_summarised)
  }, cl=cores)


  rows <- rows %>%
    do.call(what='rbind') %>% 
    data.frame()
  
  rows$markers=fData(obj)$markers[1:n]
  rows$id=rownames(fData(obj))[1:n]

  return(rows)
}

```



```{r, eval=FALSE}
start_time <- Sys.time()

iterations <- 100
sampling_rate <- 0.8

proportions_per_rep <- NULL

for(level in names(all_datasets)){
  for(condition in names(all_datasets[[level]])){
    print(level)
    print(condition)
    input_data <- all_datasets[[level]][[condition]]
    
    proportions_per_rep[[level]][[condition]] <-
      unique(pData(all_datasets[[level]][[condition]])$replicate) %>%
      lapply(function(rep){
        print(rep)
  
        .data <- all_datasets[[level]][[condition]]
        
        proportions <- get_proportions(
          obj=.data[,pData(.data)$replicate==rep],
          iterations=iterations,
          sample_proportion=sampling_rate,
          cores=4)
      
        proportions <- proportions %>% mutate(replicate=rep)
        
        return(proportions)
      })
  }
}



end_time <- Sys.time()

print(end_time-start_time)

proportions_per_rep %>% saveRDS('./out/proportions_per_rep.rds')
```



```{r}
proportions_per_rep <- readRDS('./out/proportions_per_rep.rds')

```


Combine into a single results table
```{r}

proportions_per_rep_single_table <- proportions_per_rep %>%
  names() %>%
  lapply(function(level){
    proportions_per_rep[[level]] %>%
      names() %>%
      lapply(function(cond){
        proportions_per_rep[[level]][[cond]] %>%
          do.call(what='rbind') %>%
          mutate(condition=cond)
        }) %>% do.call(what='rbind')
  })

names(proportions_per_rep_single_table) <- names(proportions_per_rep)
```



Rename a few columns
```{r}

proportions_per_rep_single_table <- proportions_per_rep_single_table %>% 
  lapply(function(x){
  
    dplyr::rename(x,
      Cytosol_Light=mean_Cytosol_Light,
      Membrane=mean_Mitochondrion,
      Nucleolus=mean_Nucleolus,
      Nucleus=mean_Nucleus,
      Cytosol=mean_Cytosol,
      sd_Membrane=sd_Mitochondrion)
  
  })


```


Next, we want to generate some standard tables of summarised proportions across the replicates. For this, we will also filter by:

- Variance explained over threshold (TBD)
- (Absolute value of) Intercept below a threshold (TBD)
- Number of observations >= 2


Let's explore the distributions for variance explained and intercept.
```{r}
x <- proportions_per_rep_single_table$gene
summary(x$mean_.Intercept.)
summary(x$mean_var_explained)

p <- ggplot(x, aes(mean_var_explained)) +
  geom_histogram() +
  theme_camprot()

print(p)
print(p + aes(mean_.Intercept.))


ggplot(x, aes(mean_var_explained, mean_.Intercept.)) +
  geom_point(alpha=0.05, size=0.2, colour='grey30') +
  annotate("rect", xmin = .9, xmax = 1, ymin = -0.05, ymax = 0.05,
           alpha = .2, fill=get_cat_palette(2)[2], colour=NA) +
  geom_density2d(colour=get_cat_palette(1)) +
  theme_camprot()
```

How many genes fall into mean variance explained < 0.85 and/or intercept > 0.05?
```{r}
x %>%
  mutate(low_var=mean_var_explained<0.85,
         high_intercept=abs(mean_.Intercept.) > 0.05) %>%
  group_by(low_var, high_intercept) %>%
  tally()
```
OK, so the about filters will remove ~ 10% of the proportion estimations and seem very reasonable. Let's see how many genes will remain.

First, if we just filter to retain all genes at least 2/3 quantifications
```{r}
print(length(unique(x$id)))

x %>%
  filter(is.finite(Cytosol)) %>%
  group_by(id, condition) %>%
  summarise(n=length(Cytosol), 
            Cytosol=mean(Cytosol)) %>%
  filter(n>=2) %>%
  pivot_wider(id_cols=id, names_from=condition, values_from=Cytosol) %>%
  filter(is.finite(DMSO), is.finite(Tg)) %>%
  nrow()

```

And now if we use the variance explained and intercept thresholds too...
```{r}
for(name in names(proportions_per_rep_single_table)){
    print(name)
    x <- proportions_per_rep_single_table[[name]]
    
    print(length(unique(x$id)))
    
    x %>% 
      filter(is.finite(as.numeric(Cytosol))) %>%
      group_by(id, condition) %>%
      summarise(n=length(Cytosol), 
                Cytosol=mean(as.numeric(Cytosol))) %>%
      filter(n>=2) %>%
      pivot_wider(id_cols=id, names_from=condition, values_from=Cytosol) %>%
      filter(is.finite(as.numeric(DMSO)), is.finite(as.numeric(Tg))) %>%
      nrow() %>%
      print()
    
    x %>%
      filter(mean_var_explained > 0.85,
             abs(as.numeric(mean_.Intercept.)) < 0.05) %>%
      filter(is.finite(as.numeric(Cytosol))) %>%
      group_by(id, condition) %>%
      summarise(n=length(Cytosol), 
                Cytosol=mean(as.numeric(Cytosol))) %>%
      filter(n>=2) %>%
      pivot_wider(id_cols=id, names_from=condition, values_from=Cytosol) %>%
      filter(is.finite(DMSO), is.finite(Tg)) %>%
      nrow() %>%
      print()
  }
```

OK, so we have quantification in both DMSO and Tg for 14203/14671 genes if we don't filter by variance explained or intercept.

With the above filters, this drops to 13539, which seems reasonable.

Before we perform the filtering, we need to remove the transcript quantification values from failed models and update the column types
```{r}
is_all_numeric <- function(x) {
  !any(is.na(suppressWarnings(as.numeric(na.omit(x))))) & is.character(x)
}

proportions_per_rep_single_table$transcript <- 
  proportions_per_rep_single_table$transcript %>%
  filter(!grepl('Error|NaN', Cytosol)) %>%
  mutate_if(is_all_numeric,as.numeric)

str(proportions_per_rep_single_table$transcript)

```
Filter the proportions tables using these thresholds
```{r}
proportions_per_rep_single_table_flt <- proportions_per_rep_single_table %>%
  lapply(function(x){
    x %>%
      filter(mean_var_explained > 0.85,
             abs(mean_.Intercept.) < 0.05) %>%
      filter(is.finite(Cytosol))
  })


proportions_per_rep_single_table %>% lapply(nrow)
proportions_per_rep_single_table_flt %>% lapply(nrow)

```

Make table summarising across the replicates.
```{r}
proportions_single_table <- proportions_per_rep_single_table_flt %>%
  lapply(function(x){
    x %>%
      group_by(id, condition) %>%
      summarise(n=length(Cytosol), 
                sd_Cytosol=sd(Cytosol),
                sd_Cytosol_Light=sd(Cytosol_Light),
                sd_Nucleus=sd(Nucleus),
                sd_Nucleolus=sd(Nucleolus),
                sd_Membrane=sd(Membrane),
                Cytosol=mean(Cytosol),
                Cytosol_Light=mean(Cytosol_Light),
                Nucleus=mean(Nucleus),
                Nucleolus=mean(Nucleolus),
                Membrane=mean(Membrane)) %>%
      filter(n>=2) %>%
      dplyr::select(-n)
  })
```

```{r}

proportions_per_rep_single_table %>% 
  saveRDS('./out/proportions_per_rep_single_table.rds')

proportions_per_rep_single_table_flt %>%
  saveRDS('./out/proportions_per_rep_single_table_flt.rds')

proportions_single_table %>%
  saveRDS('./out/proportions_single_table.rds')
```



